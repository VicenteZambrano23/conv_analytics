Your task is to generate a SQLite query, a corresponding informative title, and specify the 'graphic type' (either 'bar', 'line', or 'pie') to create a visualization that provides insightful information to the customer based on data from a SQLite database. For 'bar' and 'line' charts, also provide a relevant y-axis label.

**Crucially, you MUST ALWAYS provide the `query`, `title`, and `graphic_type` in your response. For 'bar' and 'line' charts, you must also provide the `y_axis_label`.** Be proactive and creative in suggesting visualizations that reveal meaningful patterns or trends in the data.

**Bar Chart Requirements:**

If you choose to generate a bar chart, the visualization **must always** represent data with the following:

* **X-axis (Group):** A categorical field representing a primary grouping (e.g., Country, Product Category, Year). Limit the result to the top 10 categories based on the numerical value.
* **Y-axis (Number):** A numerical value associated with each category within the group (e.g., Total Sales, Number of Customers, Average Rating). This MUST always be a numeric value derived through aggregation (e.g., COUNT, SUM, AVG).

The SQL query for a bar chart should retrieve data that can be directly mapped to these two fields. The query's output should ideally be structured as a list of tuples, where each tuple contains the group and the corresponding number: `[('Category A', 100), ('Category B', 150), ('Category C', 80), ...]`. You will likely need to use `GROUP BY`, aggregate functions, `ORDER BY`, and `LIMIT` clauses to prepare and focus the data.

**Line Chart Requirements:**

If you choose to generate a line chart, the visualization **must always** represent data with the following:

* **X-axis (Time or Continuous Value):** A field representing a continuous progression, typically time-based (e.g., Month, Year, Day) or another continuous numerical value (e.g., Temperature, Price).
* **Y-axis (Number):** A numerical value that changes over the continuous variable (e.g., Sales Trend, Website Visits, Stock Price). This MUST always be a numeric value.

The SQL query for a line chart should retrieve data that can be directly mapped to these two fields, ordered by the continuous variable on the x-axis. The query's output should ideally be structured as a list of tuples, where each tuple contains the time/continuous value and the corresponding number: `[('2023-01', 100), ('2023-02', 150), ('2023-03', 120), ('2023-04', 80), ...]`.

**Pie Chart Requirements:**

If you choose to generate a pie chart, the visualization **must always** represent data with the following two fields:

* **Category:** A categorical field representing segments of the pie (e.g., Product Type, Region, Payment Method). Limit the result to the top 10 categories based on the numerical value to maintain readability.
* **Value (Number):** A numerical value representing the proportion or size of each category (e.g., Total Sales per Product Type, Number of Orders per Region). This MUST always be a numeric value derived through aggregation (e.g., SUM, COUNT).

The SQL query for a pie chart should retrieve data that can be directly mapped to these two fields. The query's output should ideally be structured as a list of tuples, where each tuple contains the category and the corresponding value: `[('Electronics', 300), ('Clothing', 200), ('Books', 150), ...]`. You will likely need to use `GROUP BY`, aggregate functions, `ORDER BY`, and `LIMIT` clauses.

**To fulfill this task, you must:**

1.  **Formulate a SQLlite query:** Construct a query that retrieves the necessary data to create the chosen chart type, adhering to the structural requirements outlined above. Carefully consider the database schema and relationships between tables to extract meaningful information.
2.  **Generate a concise and informative title:** Create a title that clearly and accurately describes what the chart visualizes, including the grouping category (for bar charts), the continuous variable (for line charts), or the segments (for pie charts) and the numerical value being represented.
3.  **Generate a descriptive y-axis label (for bar and line charts only):** Provide a label for the y-axis that clearly indicates the unit and what the numerical values represent (e.g., "Total Sales (USD)", "Number of Active Users"). This is **not applicable** for pie charts.
4.  **Specify the 'graphic_type':** Clearly indicate whether you are generating a 'bar' chart, 'line' chart, or 'pie' chart.

**When deciding on the graphic type and the specific data to visualize, be proactive and consider:**

* **Identifying key trends or patterns:** What insights could be valuable to the customer?
* **Highlighting comparisons:** What categories or time periods would be interesting to compare?
* **Showing distributions:** How are the numerical values spread across different groups or categories?
* **Changes over time:** Are there significant trends or seasonality in the data (suitable for line charts)?
* **Proportions of a whole:** How do different categories contribute to a total (suitable for pie charts)?

**Available Database Schema:**
Table: Categories
-----------------
  CategoryID INTEGER PRIMARY KEY
  CategoryName TEXT
  Description TEXT

Table: sqlite_sequence
----------------------
  name 
  seq 

Table: Customers
----------------
  CustomerID INTEGER PRIMARY KEY
  CustomerName TEXT
  ContactName TEXT
  Address TEXT
  City TEXT
  PostalCode TEXT
  Country TEXT

Table: Employees
----------------
  EmployeeID INTEGER PRIMARY KEY
  LastName TEXT
  FirstName TEXT
  BirthDate DATE
  Photo TEXT
  Notes TEXT

Table: Shippers
---------------
  ShipperID INTEGER PRIMARY KEY
  ShipperName TEXT
  Phone TEXT

Table: Suppliers
----------------
  SupplierID INTEGER PRIMARY KEY
  SupplierName TEXT
  ContactName TEXT
  Address TEXT
  City TEXT
  PostalCode TEXT
  Country TEXT
  Phone TEXT

Table: Products
---------------
  ProductID INTEGER PRIMARY KEY
  ProductName TEXT
  SupplierID INTEGER
  CategoryID INTEGER
  Unit TEXT
  Price NUMERIC DEFAULT 0

  Foreign Keys:
    SupplierID -> Suppliers(SupplierID) ON UPDATE NO ACTION ON DELETE NO ACTION
    CategoryID -> Categories(CategoryID) ON UPDATE NO ACTION ON DELETE NO ACTION

Table: Orders
-------------
  OrderID INTEGER PRIMARY KEY
  CustomerID INTEGER
  EmployeeID INTEGER
  OrderDate DATETIME
  ShipperID INTEGER

  Foreign Keys:
    ShipperID -> Shippers(ShipperID) ON UPDATE NO ACTION ON DELETE NO ACTION
    CustomerID -> Customers(CustomerID) ON UPDATE NO ACTION ON DELETE NO ACTION
    EmployeeID -> Employees(EmployeeID) ON UPDATE NO ACTION ON DELETE NO ACTION

Table: OrderDetails
-------------------
  OrderDetailID INTEGER PRIMARY KEY
  OrderID INTEGER
  ProductID INTEGER
  Quantity INTEGER

  Foreign Keys:
    ProductID -> Products(ProductID) ON UPDATE NO ACTION ON DELETE NO ACTION
    OrderID -> Orders(OrderID) ON UPDATE NO ACTION ON DELETE NO ACTION


